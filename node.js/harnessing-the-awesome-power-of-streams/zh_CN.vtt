WEBVTT

00:00.001 --> 00:03.075
大家请看我的大屏幕

00:03.075 --> 00:08.340
好，今天我要和大家聊聊：如何充分利用stream的超强威力

00:08.340 --> 00:12.790
我觉得stream是Node中最未被充分利用的一部分

00:12.790 --> 00:17.325
但总体说来，却正是stream，赋予了Node以及JavaScript不可思议的魔力

00:17.325 --> 00:22.095
回到六十年代，这里要反复强调

00:22.095 --> 00:23.885
不，别想了，闭嘴！（台下不知发生何事）

00:23.885 --> 00:31.555
好，回到六十年代，有个叫Doug……，事实上重音不能在“I”上

00:31.555 --> 00:34.490
有个叫Doug McIlroy的家伙

00:34.490 --> 00:42.030
貌似，貌似，将文件夹摔在地上（随便吧，不重要），怒斥道：

00:42.030 --> 00:46.420
不行，Unix必须得有Stream，否则老子TMD就不干了

00:46.420 --> 00:49.985
酷毙了，归功于这个“疯子”，我们现在有了Stream

00:49.985 --> 00:55.455
简单来说，stream视程序为一段段代码片段

00:55.455 --> 00:58.830
就好比是花园中的软管，可以拼接在一起

00:58.830 --> 01:01.915
我觉得这里用软管拼接的比喻相当贴切

01:01.915 --> 01:04.435
首先要介绍的第一种stream是readable stream

01:04.435 --> 01:08.980
readable stream其实就是事件提供商（event vendor），产生data事件和end事件

01:08.980 --> 01:10.645
也许不止如此，不过那些都不重要

01:10.645 --> 01:17.120
我们来举个readable stream的例子

01:17.120 --> 01:19.525
vi start.js(备注: 用vi编辑器打开start.js文件)

01:19.525 --> 01:23.290
ok，首先要做的，也许你见过

01:23.290 --> 01:29.155
我们用fs.createReadStream，我这里有个字典文件，里面有很多单词

01:29.155 --> 01:35.120
然后，可以用pipe，就好比Unix中将stderr pipe到stdout

01:35.120 --> 01:42.770
然后，执行它，酷！所有的单词都在stdout打印出来了

01:42.770 --> 01:50.715
stream真正酷的地方在于，你知道吗，不需要将所有的数据先全部载入到内存中。而是会一段段数据不间断地输出

01:50.715 --> 01:56.310
在stream中，这真的很酷，因为（执行）结果就好像是即时获得的

01:56.310 --> 02:05.285
除此之外，你还可以写出更加有意思的程序，比方说，如果不想让stream在stdout上写完数据后退出的话，
可以使用{end: false}

02:05.285 --> 02:11.145
相比用stream而言，自己写一个stream有些许复杂

02:11.145 --> 02:16.210
对于readable stream，首先要做的，代码有少许改变，不过不用太担心，也不用去强记

02:16.210 --> 02:19.780
首先要做的就是将readable属性设置为true

02:19.780 --> 02:25.646
这里就是这个简单例子所有的代码：它分发data事件，（数据）就是一个计数器

02:25.646 --> 02:30.950
如果运行5.js文件

02:30.950 --> 02:35.560
酷！在屏幕最下方，能看到一串无限长的数字

02:35.560 --> 02:38.520
并且输出速度越来越快，这是因为数字越来越多

02:38.520 --> 02:49.370
不过，如果想要在两秒钟后停止的话，我们只要分发end事件即可

02:49.370 --> 02:52.290
好了，一秒、两秒，结束！

02:52.290 --> 03:00.385
酷！除了能够pipe数据之外，真正酷的还在于

03:00.385 --> 03:04.960
我们还能从头开始创建writable stream

03:04.960 --> 03:11.155
如果你对Node很熟悉，你或许（我也希望）对下面的代码很熟悉

03:11.155 --> 03:14.760
fs.createWriteStream, 赞~

03:14.760 --> 03:18.250
因为，剩下的就是往stream里面写数据

03:18.250 --> 03:27.595
由于这里已经是一个文件了，就没有像用一个大stream或者大的buffer来将
后续的数据拼接起来的必要了

03:27.595 --> 03:35.185
你只需……，好了，如果运行该程序，并cat output.txt（查看文件内容）

03:35.185 --> 03:39.235
噢，酷！数据结果一样

03:39.235 --> 03:48.125
还有一个很酷的就是：你可以将像process.stdin这样的readable stream视作标准的readable stream
并将其pipe给writable stream

03:48.125 --> 03:50.720
如果运行2（.js）文件

03:50.720 --> 03:58.840
abc, def, 查看output.txt文件就会发现，其内容和我们输入的完全一致
和我们预期的一样

03:58.840 --> 04:04.330
从头开始创建这类writable stream有点难度

04:04.330 --> 04:06.145
首先，将writable属性设置为true

04:06.145 --> 04:12.665
这个属性是pipe内部使用的，这样我们就能process.stdin.pipe到writable stream了

04:12.665 --> 04:17.810
我们有了writable stream，并设置了end函数，在Node中，此处要注意（选中的代码行）

04:17.810 --> 04:20.985
这只是种约定，你也可以调用end函数，并传入一个对象

04:20.985 --> 04:27.550
我们调用.write，记得这里要留意下

04:27.550 --> 04:31.025
不过，如果使用一些第三方库的话，就没有这个问题了（库一般会处理掉）

04:31.025 --> 04:42.410
好了，如果运行该程序，就能做类似的事情：将所有输入的内容打印出来

04:42.410 --> 04:47.520
如果结束stream，就能看到一个end!的提示消息

04:47.520 --> 04:52.690
超酷！事实上，我们可以利用自定义writable stream做更有用的事情

04:52.690 --> 04:57.480
比方说，我们来统计输入的字节数，并在stream结束时，将结果输出到stdout

04:57.480 --> 05:06.045
代码就在这里，首先从0开始，并且每次都加上buf.length，最后，输出字节总数

05:06.045 --> 05:16.080
运行该程序，abc，def，好，结束！结果输出字节总数为8
因为每行还有一个换行符（一行就是4个），酷！

05:16.080 --> 05:18.885
好了，这就是writable stream

05:18.885 --> 05:23.360
下面要介绍的非常重要

05:23.360 --> 05:30.245
这是一个从Dominictarr借鉴过来的想法（概念）

05:30.245 --> 05:34.720
叫做through stream，through stream是readable writable stream

05:34.720 --> 05:40.005
它也并非是唯一的一种readable writable stream，不过，它工作方式像
readable writable stream（像过滤器（filter））

05:40.005 --> 05:46.785
举例来说，就好比是Unix中的grep，grep你应该知道吧，
它接收stdin作为输入，做一些处理之后，将结果输出到stdout

05:46.785 --> 05:48.845
就好像：从这里到那里

05:48.845 --> 05:55.645
下面就让我们来实践下，我们创建一个新的stream，并将readable和writable都设为true

05:55.645 --> 05:57.585
结合前两个例子

05:57.585 --> 06:00.885
我们可以拥有一个write stream，但同时还可以分发data事件

06:00.885 --> 06:06.790
很酷吧！这里，我将输入的字符以大写形式输出，以此来形成一个“扩音”stream的效果

06:06.790 --> 06:10.925
效果会很明显，对于end函数，我们处理和先前保持一样

06:10.925 --> 06:17.910
接下来，将stdin pipe到ts，ts效果类似ls

06:17.910 --> 06:24.650
好了，运行3.js，abc，hello lisboa，然后结束！

06:24.650 --> 06:27.805
噢，不！噢，对，我忘记pipe了

06:27.805 --> 06:33.920
好吧，此前，代码是这样的，事实上，这里还需要讲ts pipe到输出源

06:33.920 --> 06:43.045
好了，现在有了4.js，输入：beep boop 然后结束
输出了大写形式的消息

06:43.045 --> 06:46.425
太棒了！这就是through stream

06:46.425 --> 06:49.815
好，这是writable stream、这是through stream

06:49.815 --> 06:52.441
这是一张我自己画的图，来解释刚刚发生的一切

06:52.441 --> 06:57.485
中间有个函数，两端是两个可互相转换的机器

06:57.485 --> 07:02.380
接下来要介绍的内容我觉得也很重要：pause stream

07:02.380 --> 07:05.540
pause stream也是一类through stream

07:05.540 --> 07:12.885
在Node中，pipe内部有一种机制，可以让你处理后续数据

07:12.885 --> 07:21.680
调用pause暂停，并当想要重新开始获取数据时，就调用.resume，
就好比是出水口有个阀门，关闭就不出水，打开就出水

07:21.680 --> 07:25.525
可以用水管互相连接来做比喻，如果这有助于理解的话

07:25.525 --> 07:28.855
这里有一个pause stream的例子

07:28.855 --> 07:30.155
我们来看下

07:30.155 --> 07:41.645
这是一个http服务器，它将我们的输入都写到output.txt文件

07:41.645 --> 07:46.740
我首先echo beep boop，接着用curl，最后运行该程序

07:46.740 --> 08:02.180
node 0.js，接着输入curl -sSNT- localhost:3000
看到了ok

08:02.180 --> 08:07.510
现在，输入的内容应当已经通过writable stream写到output.txt文件中了

08:07.510 --> 08:10.110
好，我们cat出来看看，酷！看到了！

08:10.110 --> 08:15.555
超赞！但是，假设这个时候需求变更了

08:15.555 --> 08:19.560
假设现在要在写数据前需要先创建一个文件夹

08:19.560 --> 08:24.595
这个时候，我们就不得不调用fs.mkdir，并用一个随机的id来表示文件夹名字

08:24.595 --> 08:29.645
所以，这段代码用来生成id，并将fs.mkdir放在这里

08:29.645 --> 08:34.465
好，应该差不多了，对吧？

08:34.465 --> 08:43.220
唔，看下，同样的，这里不再是res.end('ok')，而是以id结束

08:43.220 --> 08:47.540
好，结果应该是，哦不，貌似写多文件了

08:47.540 --> 08:51.075
node 2.js, 就是它!

08:51.075 --> 09:00.785
好，node 2.js，ok，酷！结果显示了id，数据就应该在数据目录下的output.txt文件中了

09:00.785 --> 09:04.920
尼玛，居然是空的！怎么回事？

09:04.920 --> 09:08.270
我们再来试下，也许这次就好了

09:08.270 --> 09:17.240
好，果然好了！有点诡异

09:17.240 --> 09:21.720
这并非“事故”，而是我们的代码有bug隐患

09:21.720 --> 09:27.970
我们先调用fs.mkdir，然后pipe到writable stream

09:27.970 --> 09:35.510
问题来了，如果data事件在fs.mkdir的回调前就分发了，就会出现问题

09:35.510 --> 09:37.895
那么怎么解决这个问题呢？答案当然是 pause stream

09:37.895 --> 09:46.300
我们只要稍微改下代码，就……

09:46.300 --> 09:51.035
好，首先咱们要引入一个叫pause-stream的模块

09:51.035 --> 09:53.450
然后，创建一个pause stream，将其暂停

09:53.450 --> 09:59.460
然后，这次不是将request pipe给ws对象

09:59.460 --> 10:10.695
而是pipe给…… ps.pipe，让我先回到上个版本

10:10.695 --> 10:13.780
好，我们pipe pause stream而不是write stream

10:13.780 --> 10:21.025
它暂停了，随后，在最后，回调函数触发后，我们调用resume来恢复stream

10:21.025 --> 10:27.520
在恢复stream的时候，也许数据已经过来了，也许还没有。pause stream会将数据buffer起来

10:27.520 --> 10:35.750
继续刚刚这个例子，这次运行更新后的版本，然后用curl

10:35.750 --> 10:40.660
再看看output文件，确认没错，这次对了

10:40.660 --> 10:44.340
你可能已经注意到了，服务器会返回id

10:44.340 --> 10:49.725
所以，事实上，我们可以使用Unix的聚合（aggregator），来打印output.txt中的数据

10:49.725 --> 10:53.470
好，这就在输出文件内容

10:53.470 --> 10:57.840
如你所见，现在每次都能够获得正确的输出结果

10:57.840 --> 11:01.715
上述就是使用pause stream来规避此前获取数据的问题

11:01.715 --> 11:03.755
pause stream很赞

11:03.755 --> 11:11.650
好，下面要闪亮登场的是duplex stream

11:11.650 --> 11:14.355
duplex stream也是readable writable stream

11:14.355 --> 11:19.565
不过，duplex非常酷，因为它很想电话

11:19.565 --> 11:22.705
它不仅仅像through stream那样是一个过滤器（如grep）

11:22.705 --> 11:24.470
它更像是“谈话”

11:24.470 --> 11:29.395
比方说，A要和B通话，这个时候，B也需要和A通话

11:29.395 --> 11:33.170
就像这类循环的实时通讯

11:33.170 --> 11:38.610
如屏幕所示，a.pipe(b).pipe(a) 诸如此类

11:38.610 --> 11:41.610
也许，不，应该是你肯定用过duplex stream

11:41.610 --> 11:55.845
有个很好的模块叫duplexer，它衍生自event-stream模块

11:55.845 --> 12:02.545
它可以将readable stream和writable stream合成到一个duplex stream中

12:02.545 --> 12:06.605
从某种意义上来说，duplex可以说是stream之王

12:06.605 --> 12:13.360
特别是当你有一个request对象和response对象时，就可以将两者拼接起来，形成一个duplex stream

12:13.360 --> 12:22.665
这样很酷，因为你可以将其他的duplex stream以及request、response对象拼接在一起
再将其拼接到另外一个stream上，然后再拼回到duplex stream

12:22.665 --> 12:25.600
duplex真的超赞

12:25.600 --> 12:31.630
在后面会看到很多duplex stream，这里暂且先跳过

12:31.630 --> 12:37.440
好了，另外一种through stream，我一定，一定要介绍的，就是JSONStream

12:37.440 --> 12:38.985
JSONStream也超赞！

12:38.985 --> 12:48.025
假设这里有一个125Mb大的文件，包含了旧金山的所有的地界信息

12:48.025 --> 12:53.455
真的有这个文件哦，我花了将近3小时才搞定

12:53.455 --> 13:02.040
如果，我们“霸王硬上功”——直接讲其载入到内存中

13:02.040 --> 13:05.230
你非得等上一段很长的时间不可

13:05.230 --> 13:10.845
完全载入，也许得花上几分钟的时间，

13:10.845 --> 13:16.675
而如果我们这里发挥stream的威力，使用JSONStream模块的话

13:16.675 --> 13:18.790
会提升不少（时间短很多）

13:18.790 --> 13:24.230
回到stream，设置我们要获取的值

13:24.230 --> 13:37.215
是坐标（coordinates）属性，该属性在features键中，features中geometry键

13:37.215 --> 13:42.370
里面有coordinates键，coordinates键就是我们真正需要的数据

13:42.370 --> 13:50.675
那么，怎么做呢？我们用JSONStream，JSONStream.parse，该方法接收一个包含类似键/值形式的数组作为参数

13:50.675 --> 13:53.375
事实上不仅仅是键/值，还可以用一些模式等

13:53.375 --> 14:00.235
“features”是一个数组，所以，如果我们需要数组所有的元素，就可以简单的指定true即可，
无需将所有的名字列出来

14:00.235 --> 14:03.755
接下来是geometry键，然后是coordinates键

14:03.755 --> 14:11.860
我们只需用console.dir将值打印出来，并将一个read stream pipe给parser

14:11.860 --> 14:17.550
好了，运行该程序，也许少了一步

14:17.550 --> 14:23.590
噢，我还在pause stream的例子中，这就是为啥没有反应

14:23.590 --> 14:26.290
好，再次运行该程序，好，酷！

14:26.290 --> 14:37.405
和fs.readFile('citylots.json')不同，
我们不用将所有的数据都载入内存

14:37.405 --> 14:40.190
我们直接就可以处理

14:40.190 --> 14:44.910
非常酷吧，stream好样的！

14:44.910 --> 14:51.340
再来做些改动，假设我们这次需要从stream中读取数据，并将其写回到文件中

14:51.340 --> 14:58.715
没问题，我们可以用JSONStream.stringify
这和JSON的stringify类似，只是是stream的方式

14:58.715 --> 15:04.090
我们可以stringify.pipe 到一个write stream，这里就是coords.json文件

15:04.090 --> 15:11.220
好，我们运行9.js

15:11.220 --> 15:20.050
卡住了，这是因为正在往coords.json文件中写数据

15:20.050 --> 15:25.060
如果我们查看下文件内容的字数，就会发现在不断增长

15:25.060 --> 15:29.255
这是因为stream正在工作，我们不需要将整个一大坨数据加载到内存中

15:29.255 --> 15:32.285
这对于书写可伸缩的web服务而言，非常非常的重要

15:32.285 --> 15:35.105
尤其是写Node的时候，应当要非常擅长处理这类事情

15:35.105 --> 15:41.890
记得在适用的场景下，尽可能的使用JSONStream

15:41.890 --> 15:47.115
好，下一个要展示的，酷毙了的东西叫scuttlebutt

15:47.115 --> 15:52.245
scuttlebutt是……
哦，对了，dnode也属于duplex stream一例

15:52.245 --> 15:55.930
dnode会在后面我要展示的“碉堡”了的demo充当重要角色

15:55.930 --> 16:03.060
言归正传，scuttlebutt并非是指和水相关的装置

16:03.060 --> 16:11.900
这里的scuttlebutt是一种gossip协议，用来使得网络中不同节点间能够通讯

16:11.900 --> 16:17.570
它没有标准的数据源，而只是到处传递消息

16:17.570 --> 16:24.130
为了同步状态，这很酷，它属于一种基于历史的算法（history based algorithm）

16:24.130 --> 16:31.506
应该说这超赞，好，要使用scuttlebutt

16:31.506 --> 16:38.305
这里我只使用scuttlebutt模型，如果要看更多相关的例子，可以看一个叫crdt的模块

16:38.305 --> 16:43.470
通过scuttlebutt模型, 每个模型都可以创建stream

16:43.470 --> 16:50.981
这里，在A节点上设置一个值，并将它pipe给B节点

16:50.981 --> 17:01.185
运行该程序，酷！尽管我们是在节点A上设置的值，但是我们可以在节点B上捕获到事件

17:01.185 --> 17:04.835
这里我们只是pipe出去，事实上，我们可以将其用在网络连接上

17:04.835 --> 17:11.795
这里，创建一个http服务器，然后做些类似设置值，取值的操作

17:11.795 --> 17:20.035
这部分很酷，如果我……
第一个参数是端口号

17:20.035 --> 17:27.550
so we listen on port 8000 and we can curl to this

17:27.550 --> 17:31.325
so, that's getting key a, but I can set it for printing equals

17:31.325 --> 17:35.410
now, I get key a, it's 5, that's neat and I can do that
as much as I want

17:35.410 --> 17:44.400
but if I spin up another server on port 8001 and
connect that with scuttlebutt to port 8000

17:44.400 --> 17:50.455
now I can curl localhost:8001 key a, that's the same
and I can actually set it to new value

17:50.455 --> 17:54.855
and get it on port 8000 and that value is proper got

17:54.855 --> 17:59.605
but it's cooler, because we can actually connect,
it's not just like a client-server thing

17:59.605 --> 18:10.010
we can actually connect ..., here I'll spin up a new server
on port 8002, but I only connect it to ... port 8002 to port 8001

18:10.010 --> 18:19.755
and if I turn to get ..., if I turn to set a value on 8002

18:19.755 --> 18:24.365
and then I get it on 8000, it should be the same value
and it is!

18:24.365 --> 18:33.940
this is because ... so, the server on 8002 is not directly 
connected to 8000, it's only connected through the server 8001

18:33.940 --> 18:40.705
so, basically, if you have connectedness in your graph of streams
that where everything is piped together

18:40.705 --> 18:43.605
the whole state of the entire network be eventually consistent

18:43.605 --> 18:46.020
you can just set values and get them elsewhere

18:46.020 --> 18:51.865
and you don't have to worry about like caving client and server
and how to caving a cluster of database peered to each other 

18:51.865 --> 18:58.740
which, I'll totally rush to next part is ... skipping that

18:58.740 --> 19:02.690
this craziness

19:02.690 --> 19:06.865
so, don't worry, I'll go very fast and it'll be so awesome

19:06.865 --> 19:13.910
so, let's build a streaming web app that synchronizes state
across all users

19:13.910 --> 19:16.105
listens for server events, has an rpc control interface

19:16.105 --> 19:19.515
runs multiple streams over mux-demux, in node and the browser

19:19.515 --> 19:24.840
and load balanced across multiple web servers that
peering with each other over scuttlebutt which is 
gossip protocol

19:24.840 --> 19:28.105
ok, that sounds awesome, let's do it

19:28.105 --> 19:32.210
so, the first thing we need to do is well, we'll create a scuttlebutt
model and we'll create a web server

19:32.210 --> 19:35.940
and here the web server just listens on the port

19:35.940 --> 19:41.265
well, what happened, it was gonna too fast, that's crazy

19:41.265 --> 19:46.760
ok, so, we create a web server, we'll create a stream

19:46.760 --> 19:50.785
and then, we can just add a thing here

19:50.785 --> 19:56.010
so, if you are familiar with couchdb, it has sweet
replicate api but what we can succeed about it is

19:56.010 --> 20:00.490
you can only ... it's lot of only ... it's fully like 
servers connecting clients

20:00.490 --> 20:07.005
but, with this, anybody can connect to our server, replicate
and not only replicate from us but replicate to us

20:07.005 --> 20:13.055
and that information will be passed around our entire network
over streams, it would be, it's gonna be really awesome

20:13.055 --> 20:23.895
ok, so, some other thing, we'll use this module I wrote called
emit-stream to turn a event emitter into a stream and back
into an event emitter again

20:23.895 --> 20:31.085
so, we can use other crazy awesome module called mux-demux
which is mentioned earlier today, which is awesome

20:31.085 --> 20:37.305
and that let us take multiple streams, pack them into a single stream
and I have a picture of this

20:37.305 --> 20:43.520
well, that's emit-stream, oh, where is my picture, it was awesome
anyway, it doesn't matter

20:43.520 --> 20:50.810
so, we have a mux-demux and that just like is a crazy video thing

20:50.810 --> 20:56.790
so, whatever mux-demux, we'll create a stream called state
that's for our synchronization

20:56.790 --> 21:00.375
and we can create another stream called events
that's for our event system

21:00.375 --> 21:05.770
which will turn an event emitter into a stream
back to an event emitter on the other side and  vice versa

21:05.770 --> 21:12.815
ok, cool, so, the other thing we can do is actually emit events

21:12.815 --> 21:19,615
and we can emit like a part event also when the request ends
it's a kind cool

21:19,615 --> 21:21.805
so, this part is really freaking awesome

21:21.805 --> 21:26.080
so, we have this, you know that slices string that I show you

21:26.080 --> 21:32.940
so, now , for every additional argument passed the initial 
argument that I give which is the port number 

21:32.940 --> 21:37.800
it'll connect and replicate with in a period of fashion
every other web server 

21:37.800 --> 21:40.315
so, we can just tight multiple web servers, they all talk to 
each other

21:40.315 --> 21:46.555
they all use gossip protocol to communicate, 
all of the state across all of the network are eventually consistent

21:46.555 --> 21:50.850
and we can plug this directly into browsers also,
which is the next part

21:50.850 --> 21:55.830
so, after some login staff, yeah, here is our web server

21:55.830 --> 22:06.090
and, yes, we can use shoe, which is a module that I wrote
all it is is really thin wrapper on top of sockjs that give you a stream

22:06.090 --> 22:13.855
that's all it does. that's amazing, you don't have to have
like weird thing, you can just use modules, let's do that

22:13.855 --> 22:22.250
so, we have our stream right, and all we need to do to replicate
is stream.pipe(createStream()).pipe(stream)

22:22.250 --> 22:29.445
and that's the mux-demux connection， it's exactly the same as
our http streaming connection to replicate the states

22:29.445 --> 22:36.385
so, we wrote a function, it'll turn a string, we can use that
anywhere to replicate anywhere browsers, servers like other servers

22:36.385 --> 22:40.060
it doesn't matter, we just send data and the network figures it out

22:40.060 --> 22:44.955
so, there's some plumbing in here too

22:44.955 --> 22:50.545
I snuck dnode into this example also because just why not

22:50.545 --> 22:54.465
here I have a function that I just defined and you know, 
it's dnode 

22:54.465 --> 23:01.275
so, and with mux-demux, all I have to do is create an additional
stream, and just like pipe it through

23:01.275 --> 23:08.125
and that's all, so, to recapitulate a little bit

23:08.125 --> 23:10.535
we have dnode stream, we've got mux-demux

23:10.535 --> 23:14.095
here's our browser code actually to render this

23:14.095 --> 23:21.125
so, it draws a big blue box and what's really cool is
we are using actually exactly the same modules

23:21.125 --> 23:25.545
we won't actually know except for maybe there is document.body,
this is actually browser code

23:25.545 --> 23:28.710
cuz we're using scuttlebutt, we're using mux-demux

23:28.710 --> 23:31.725
it's all just browser fights up, we're using emit-stream
just the same

23:31.725 --> 23:35.040
it's pretty much the same code except it has dom staff in it

23:35.040 --> 23:41.645
so, we'll go through all of this, we just recap here a little bit
and I'll actually run it and it'll be done

23:41.645 --> 23:46.980
so, we synchronize state across all uses, we listen for server events
with the emit-stream

23:46.980 --> 23:51.465
we run multiple streams over mux-demux, we load balanced across
multiple servers

23:51.465 --> 23:55.430
so, I am telling you I haven't actually demonstrate this yet

23:55.430 --> 24:02.460
in order a browser, we have an rpc control interface with dnode
so that's the all the things

24:02.460 --> 24:07.625
so, let's actually run this beast

24:07.625 --> 24:16.010
so, the first thing I'll do is I'll browserify the last version
that wasn't any good

24:16.010 --> 24:28.090
so, staticbundle.js cuz I think I was messing with that earlier
and I'll run the server on port 8000

24:28.090 --> 24:34.380
cool, and I can visit it, HOLA LISBOA, that's from dnode actually

24:34.380 --> 24:39.395
and here we just have a box, the box, it's not very fancy

24:39.395 --> 24:41.720
all you can do is drag it, right?

24:41.720 --> 24:50.865
but, if we have another user connected, and if I make it
smaller again

24:50.865 --> 24:56.050
goodness, ok, so if I move the box over here, cool
if I move it there from over here

24:56.050 --> 24:59.570
you might have seen something like socket.io, and that's great
that's reusable

24:59.570 --> 25:02.115
but, that's not intereasting enough

25:02.115 --> 25:06.520
let's actually have a load balanced server

25:06.520 --> 25:16.785
so, we'll run another server on port 8001 and connect it to other
server on 8002, connected over stream and over everything

25:16.785 --> 25:23.720
so, oh, godness, it's a little bugness, oh no, damn it
work damn it

25:23.720 --> 25:33.640
I am telling you this totally worked earlier, sort of 
oh, there it goes, yes, it totally is working kind of a little bit

25:33.640 --> 25:34.965
it's bug there but like, that's the basic idea

25:34.965 --> 25:44.765
that is all that I have to say, we'll skip some pictures,
use all of these modules, they are amazing

25:44.765 --> 25:55.730
thanks!
